---	
title: "Intersect VarScan and Strelka"	
author: "Stacy Hung"	
date: "November 25, 2019"	
output: html_document	
---	
	
This script performs the following tasks:	
1. Filters varScan predictions
2. Intersects varScan with Strelka and Mutect predictions (indels from VarScan and Strelka only)

Important notes:
- LOF is associated with 4 fields: (i) gene, (ii) gene id (usually ensembl), (iii) number of transcripts, and (iv) percentage of transcripts affected by this variant
- When the Ensembl transcript ID is not included in the output, it is really hard to filter out weird effects that end up being duplicates for a variant (e.g. whenever a variant is annotated with sequence_feature, it is also annotated with a standard effect like missense or nonsense) - to filter out these effects, it is key to include the "FEATUREID" (aka transcript ID) - then by keeping variants with annotation only via the Ensembl transcript ID, we retain a standard list of effects 

for "batch #2" samples of the GZL targeted sequencing cohort.  Note that 9 samples that were sequenced as part of this cohort, should be excluded, either due to poor DNA quality or they are composite samples ("sequential"):
 	
## Load libraries
 	
```{r}
library(dplyr)        # filter	
library(plyr)         # revalue
library(tidyr)        # separate	
library(DataCombine)  # find and replace
library(reshape2)     # colsplit
```

## Define samples to be excluded and global variables

```{r}

# read in data that contains information on tumor content and tissue type of the normal
sample.data <- read.table("/Volumes/shung/projects/gzl_targeted/data/gzl_targeted-T_N-samples.txt", sep = "\t", header = TRUE, fill = TRUE, as.is = TRUE)

# only keep samples that were sequenced as part of validation cohort
sample.data <- filter(sample.data, sample.data$result == "validation")

# extract only required columns
sample.data <- sample.data[, c("tumor.tumor_id", "tumor.tissue_type.v2", "tumor_content", "tumor.mean_target_coverage", "normal.extraction_method.v2")]
colnames(sample.data) <- c("tumor.id", "tumor.tissue_type", "tumor_content", "tumor.mean_target_coverage", "normal.extraction_method")

# exclude LMD samples that have < 40X coverage or < 100X for all other samples
sample.data.1 <- filter(sample.data, tumor.tissue_type == "FFPE_LMD" & as.numeric(tumor.mean_target_coverage) > 40)
sample.data.2 <- filter(sample.data, tumor.tissue_type != "FFPE_LMD" & as.numeric(tumor.mean_target_coverage) > 100)
sample.data <- rbind(sample.data.1, sample.data.2)

# panel genes
genes.panel <- read.table("/Volumes/shung/projects/gzl_exomes/data/target_panel_Agilent_genes.txt", header=FALSE)
genes.panel <- as.vector(genes.panel$V1)

# mappings for 3-letter amino acids to 1-letter amino acid codes	
AA.replaces <- data.frame(from = c("Ala", "Arg", "Asn", "Asp", "Asx", "Cys", "Glu", "Gln", "Glx", "Gly", "His", 	
                                   "Ile", "Leu", "Lys", "Met", "Phe", "Pro", "Ser", "Thr", "Trp", "Tyr", "Val"), 	
                          to = c("A", "R", "N", "D", "B", "C", "E", "Q", "Z", "G", "H", 	
                                 "I", "L", "K", "M", "F", "P", "S", "T", "W", "Y", "V"))	

# filter for protein coding biotypes
biotype.keeps <- c("IG_C_gene", "IG_D_gene", "IG_gene", "IG_J_gene", "IGL_V_gene", "IG_M_gene", "IG_V_gene",
                   "IG_Z_gene", "nonsense_mediated_decay", "nontranslating_CDS", "non_stop_decay",
                   "polymorphic_pseudogene", "TR_C_gene", "TR_D_gene", "TR_J_gene", "protein_coding")

# define thresholds for all samples EXCEPT for tumors paired to LMD normals
MAX_SOMATIC_PVAL = 0.05
#MIN_VAR_READS_TUMOR = 3

# ROC-defined thresholds (min variant reads vary by tumor content)
MIN_VAR_READS_TUMOR.HIGH_TC = 12
MIN_VAR_READS_TUMOR.LOW_TC = 8
MIN_VAF = 3

# apply OPTIMIZED thresholds to tumor vs. LMD normals samples
MAX_SOMATIC_PVAL.LMD_OPT = 0.1375   # OPTIMIZED
MAX_VAR_AF_NORMAL.LMD_OPT = 10      # OPTIMIZED; as a percentage

# germline variant thresholds
GERMLINE_AF_HETERO_LOW = 40   # lower bound for heterozygous germline variant
GERMLINE_AF_HETERO_HIGH = 60  # upper bound for heterozygous germline variant
GERMLINE_AF_HOMO_LOW = 90      # lower bound for homozygous germline variant

# miniumum depth at position:
MIN_DEPTH = 20;

# minimum number of variant reads in normal
MAX_VAR_READS_NORMAL = 2;

# define normal groups
normals.pooled <- c("pooled_LMD_N", "pooled normal")
normals.LMD <- c("pooled_LMD_N", "LMD")

```

## ####### ##
## VARSCAN ##
## ####### ##

```{r}
varScan.snvs <- read.table("/Volumes/shung/projects/gzl_targeted/all_samples/varscan/all_snvs.snpEff_canonical.dbsnp_annotated.cosmic_annotated.txt", sep = "\t", header = TRUE, fill = TRUE)
varScan.indels <- read.table("/Volumes/shung/projects/gzl_targeted/all_samples/varscan/all_indels.snpEff_canonical.dbsnp_annotated.cosmic_annotated.txt", sep = "\t", header = TRUE, fill = TRUE)
```

## VarScan - Processing data for filtering

```{r}
# specify type of mutation
varScan.indels$type <- "indel"
varScan.snvs$type <- "snv"

# combine snvs and indels
varScan.calls <- rbind(varScan.indels, varScan.snvs)
rm(varScan.indels)
rm(varScan.snvs)

# rename columns	
colnames(varScan.calls) <- c("sample", "chr", "pos", "external_id", "ref", "alt", "filter", 
                             "gt_normal", "gq_normal", "normal.depth", "normal.ref_reads", "normal.var_reads",
                             "normal.allele_freq", "normal.depth4", "tumor.gt", "tumor.gq", "tumor.depth",
                             "tumor.ref_reads", "tumor.var_reads", "tumor.allele_freq", "tumor.depth4", 
                             "depth", "somatic", "somatic_status", "gpv", "somatic_p_value", "allele", 
                             "effect", "impact", "gene", "feature", "feature_id", "biotype", "exon_rank", 
                             "hgvs_cdna", "hgvs_protein", "cds_pos", "cds_len", "AA_pos", "AA_len", 
                             "LOF_gene", "LOF_geneid", "LOF_num_Tr", "LOF_perc", "type")

# create a tumor_id / normal id column based on the sample id (format is <tumor_id>_<normal_id>)
varScan.calls$tumor.id <- gsub("(.*)\\_(.*)","\\1", varScan.calls$sample)
varScan.calls$normal.id <- gsub("(.*)\\_(.*)","\\2", varScan.calls$sample)

# rename specific tumor ids so that sample information can be properly mapped
tumor_id.to.mappable_tumor_id <- c("GZ-170-merged.sorted"="GZ-170-merged")
varScan.calls$tumor.id <- revalue(varScan.calls$tumor.id, tumor_id.to.mappable_tumor_id)

# remove "%" from the allele frequency	
varScan.calls$normal.allele_freq <- gsub("(.*)\\%(.*)","\\1", varScan.calls$normal.allele_freq)	
varScan.calls$tumor.allele_freq <- gsub("(.*)\\%(.*)","\\1", varScan.calls$tumor.allele_freq)	

# merge T-N data with SNVs
varScan.calls <- merge(varScan.calls, sample.data, by = "tumor.id", all.x = TRUE)

# remove excluded samples
varScan.calls <- filter(varScan.calls, varScan.calls$tumor.id %in% sample.data$tumor.id)

# use 1-letter amino acid codes
varScan.calls <- FindReplace(data = varScan.calls, 	
                                    Var = "hgvs_protein",	
                                    replaceData = AA.replaces,	
                                    from = "from",	
                                    to = "to",	
                                    exact = FALSE)	

```

## VarScan - Filtering

```{r}
# VarScan-specific filters - somatic p-value + strand bias
# --------------------------------------------------------

# filter for somatic variants
varScan.calls <- filter(varScan.calls, varScan.calls$somatic == "true")

# filter for somatic p-value depending on the LMD or not
varScan.calls <- filter(varScan.calls,
                        ((normal.extraction_method %in% normals.LMD) &
                             (as.numeric(somatic_p_value) < MAX_SOMATIC_PVAL.LMD_OPT)) |
                          ((!(normal.extraction_method %in% normals.LMD) | is.na(normal.extraction_method)) &
                             (as.numeric(somatic_p_value) < MAX_SOMATIC_PVAL)) 
                        )
varScan.calls$somatic_p_value <- NULL # no longer needed

# extract depth4 fields in order to apply strand filter
varScan.calls <-	
  separate(data = varScan.calls,	
           col = tumor.depth4,	
           into = c("tumor.ref_reads.forward", "tumor.ref_reads.reverse",
                  "tumor.var_reads.forward", "tumor.var_reads.reverse"),	
           sep = ",",	convert = TRUE,
           remove = FALSE)	
# apply the strand filter
varScan.calls <- filter(varScan.calls, 
                        !(as.numeric(tumor.var_reads.forward) > as.numeric(0.9*as.numeric(tumor.var_reads))) & 
                          !(as.numeric(tumor.var_reads.reverse) > as.numeric(0.9*as.numeric(tumor.var_reads))))
# update actual tumor depth
varScan.calls$tumor.depth <- varScan.calls$tumor.ref_reads.forward + varScan.calls$tumor.ref_reads.reverse +
  varScan.calls$tumor.var_reads.forward + varScan.calls$tumor.var_reads.reverse

# remove columns for strand bias check since they are no longer needed
varScan.calls$tumor.ref_reads.forward <- NULL
varScan.calls$tumor.ref_reads.reverse <- NULL
varScan.calls$tumor.var_reads.forward <- NULL
varScan.calls$tumor.var_reads.reverse <- NULL
varScan.calls$tumor.depth4 <- NULL

# Filters that are applied to all samples
# ---------------------------------------

varScan.calls <- filter(varScan.calls, as.numeric(varScan.calls$tumor.allele_freq) >= MIN_VAF)

# Remove non-panel genes
varScan.calls <- filter(varScan.calls, varScan.calls$gene %in% genes.panel)

# keep only variants that have a protein-altering impact
effects.exclude <- c("intron_variant", "intragenic_variant", "", "sequence_feature")
varScan.calls <- filter(varScan.calls, !(varScan.calls$effect %in% effects.exclude))
varScan.calls <- filter(varScan.calls, varScan.calls$impact != "LOW") # filter out low impact variants
varScan.calls <- filter(varScan.calls, varScan.calls$biotype %in% biotype.keeps) # filter out non protein coding biotypes
varScan.calls <- unique(varScan.calls[grep("^ENST", varScan.calls$feature_id), ])# annotated on Ensembl transcript ID


# Filters with sample-specific criteria
# ---------------------------------------

# apply different filters depending on the type of normal (LMD vs. not LMD)
varScan.calls <- filter(varScan.calls, 
                           ( (normal.extraction_method %in% normals.LMD) &
                             (as.numeric(normal.allele_freq) < MAX_VAR_AF_NORMAL.LMD_OPT)
                           ) | 
                           ( (!(normal.extraction_method %in% normals.LMD) | is.na(normal.extraction_method)) &
                             (as.numeric(normal.allele_freq) < 0.05*as.numeric(tumor.allele_freq)) &
                             (as.numeric(normal.var_reads) <= MAX_VAR_READS_NORMAL)
                           ) 
                        )

# Remove variants with a *pooled normal* that only have a dbSNP id
# Psuedocode:
#   1) Store variants from tumors matched to non-pooled normal
#   2) Store variants from tumors matched to pooled normal and do not have an rs id (no ids, or COSM id(s))
#   3) Store variants from tumors matched to pooled normal and do have an rs id (rs + COSM id(s), or rs id)
#   4) Store variants from (3) that have a COSM id
#   5) Remove list of variants from (3)
#   6) Rbind variants from 1, 2 and 4
varScan.not_pooledN <- filter(varScan.calls, !(normal.extraction_method %in% normals.pooled)) # dataset 1
varScan.pooledN <- filter(varScan.calls, normal.extraction_method %in% normals.pooled)
varScan.pooledN.no_rsid <- filter(varScan.pooledN, !grepl("rs", varScan.pooledN$external_id)) # dataset 2
varScan.pooledN.rsid <- filter(varScan.pooledN, grepl("rs", varScan.pooledN$external_id)) # dataset 3
varScan.pooledN.rs_and_COSM_id <- filter(varScan.pooledN.rsid, grepl("COSM", varScan.pooledN.rsid$external_id)) # 4
rm(varScan.pooledN.rsid)
rm(varScan.pooledN)
varScan.calls <- rbind(varScan.not_pooledN, varScan.pooledN.no_rsid, varScan.pooledN.rs_and_COSM_id)

# ROC-based thresholds
varScan.calls <- filter(varScan.calls, 
                      (as.numeric(varScan.calls$tumor_content) > 25 & 
                         as.numeric(varScan.calls$tumor.var_reads) >= MIN_VAR_READS_TUMOR.HIGH_TC) |
                        (as.numeric(varScan.calls$tumor_content) <= 25 & 
                           as.numeric(varScan.calls$tumor.var_reads) >= MIN_VAR_READS_TUMOR.LOW_TC))


# Germline filter for "pooled normal" (and not pooled LMD normal) - remove variants with VAF between 40-60, >90 (except variants with COSM id only)
## pseudocode:
#   1. Split up calls into (1) pooled normal and (2) everything else --> "not pooled normal"
#   2. For calls in (1) above, keep variants that have VAF < 40 or VAF between 60 and 90% --> "pooled, filtered VAF"
#   3. Create temporary set of calls that are inverse of above (i.e. have VAF between 40-60 or >= 90%)
#   4. Keep calls from above dataset that have COSMIC id and not rs id --> "pooled, filtered out with COSMIC id"
#   5. Combine "not pooled normal" + "pooled, filtered VAF" + "pooled, filtered out with COSMIC id"

# Step 1 - 
varScan.calls.pooledN <- filter(varScan.calls, varScan.calls$normal.extraction_method == "pooled normal")
varScan.calls.not_pooledN <- filter(varScan.calls, varScan.calls$normal.extraction_method != "pooled normal") # keep all
# Step 2 - 
varScan.calls.pooledN.filtered <- filter(varScan.calls.pooledN, (as.numeric(tumor.allele_freq) < 40) | 
                                           (as.numeric(tumor.allele_freq) > 60 & as.numeric(tumor.allele_freq) < 90) ) # keep
# Step 3 - 
varScan.calls.pooledN.filtered_out.temp <- filter(varScan.calls.pooledN, (as.numeric(tumor.allele_freq) >= 90) | 
                                               (as.numeric(tumor.allele_freq) >= 40 & as.numeric(tumor.allele_freq) <= 60) )
# Step 4 - 
varScan.calls.pooledN.filtered_out.temp.COSM <- filter(varScan.calls.pooledN.filtered_out.temp, 
                                                       grepl("COSM", varScan.calls.pooledN.filtered_out.temp$external_id) )
varScan.calls.pooledN.filtered_out.temp.COSM_not_rs <- filter(varScan.calls.pooledN.filtered_out.temp.COSM,
                                                              !grepl("rs", varScan.calls.pooledN.filtered_out.temp.COSM$external_id)) # keep

varScan.calls <- rbind(varScan.calls.not_pooledN, varScan.calls.pooledN.filtered, varScan.calls.pooledN.filtered_out.temp.COSM_not_rs)

# remove duplicates (e.g. due to multiple effects)
varScan.calls <- unique(varScan.calls)	

#write.table(varScan.calls, "/Volumes/shung/projects/gzl_targeted/all_samples/varscan/varscan.calls.filtered.txt", sep = "\t", quote = FALSE, row.names = FALSE)
	
varScan.calls$combine = as.character(paste(	
  varScan.calls$tumor.id, 	
  varScan.calls$type,
  varScan.calls$chr, 	
  varScan.calls$pos, 	
  varScan.calls$ref,	
  varScan.calls$alt,	
  sep = "."	
  ))
```

## ###### ##
## MUTECT ##
## ###### ##

```{r}
mutect.snvs <- read.table("/Volumes/shung/projects/gzl_targeted/all_samples/mutect/all_snvs.snpEff_canonical.dbsnp_annotated.cosmic_annotated.txt", sep = "\t", header = TRUE, fill = TRUE)
```

## MuTect - Processing data for filtering

```{r}
mutect.snvs$type = "snv" 

# rename columns
colnames(mutect.snvs) <- c("sample", "chr", "pos", "external_id", "ref", 
          "alt", "filter", "normal.gt", "normal.var_reads", "normal.base_qual", 
          "normal.depth", "normal.allele_freq", "normal.somatic_status", "tumor.gt", "tumor.var_reads", 
          "tumor.base_qual", "tumor.depth", "tumor.allele_freq", "somatic_status", "somatic", "VT", "allele", 
          "effect", "impact", "gene", "feature", "feature_id", "biotype", "exon_rank", "hgvs_cdna", "hgvs_protein", 
          "cds_pos", "cds_len", "AA_pos", "AA_len", "LOF_gene", "LOF_geneid", "LOF_num_Tr", "LOF_perc", "type")
                         
# create a tumor_id column based on the sample id (format is <tumor_id>_<normal_id>)
mutect.snvs$tumor.id <- gsub("(.*)\\_(.*)","\\1", mutect.snvs$sample)
mutect.snvs$normal.id <- gsub("(.*)\\_(.*)","\\2", mutect.snvs$sample)

# convert allele frequencies to percent instead of fraction
mutect.snvs$normal.allele_freq <- mutect.snvs$normal.allele_freq*100
mutect.snvs$tumor.allele_freq <- mutect.snvs$tumor.allele_freq*100

# rename specific tumor ids so that sample information can be properly mapped
tumor_id.to.mappable_tumor_id <- c("GZ-170-merged.sorted"="GZ-170-merged")
mutect.snvs$tumor.id <- revalue(mutect.snvs$tumor.id, tumor_id.to.mappable_tumor_id)

# remove excluded samples
mutect.snvs <- filter(mutect.snvs, mutect.snvs$tumor.id %in% sample.data$tumor.id)

# merge T-N data with SNVs
mutect.snvs <- merge(mutect.snvs, sample.data, by = "tumor.id", all.x = TRUE)

# use 1-letter amino acid codes
mutect.snvs <- FindReplace(data = mutect.snvs, 	
                                    Var = "hgvs_protein",	
                                    replaceData = AA.replaces,	
                                    from = "from",	
                                    to = "to",	
                                    exact = FALSE)	

# extract tumor variant reads
mutect.snvs <-	
  separate(data = mutect.snvs,	
           col = tumor.var_reads,	
           into = c("tumor.ref_reads", "tumor.var_reads"),	
           sep = ",",	convert = TRUE,
           remove = FALSE)	
mutect.snvs <-	
  separate(data = mutect.snvs,	
           col = normal.var_reads,	
           into = c("normal.ref_reads", "normal.var_reads"),	
           sep = ",",	convert = TRUE,
           remove = FALSE)	

```

## MuTect - Filtering

```{r}
# MuTect-specific filters - min tumor depth, base quality
# --------------------------------------------------------

# filter out low-quality bases (BQ < 20)
mutect.snvs <- filter(mutect.snvs, mutect.snvs$tumor.base_qual >= 20)

# unlike in VarScan, depth at variant position is not filtered; filter for min 20X coverage
mutect.snvs <- filter(mutect.snvs, as.numeric(tumor.depth) >= MIN_DEPTH)

# Filters that are applied to all samples
# ---------------------------------------

mutect.snvs <- filter(mutect.snvs, as.numeric(mutect.snvs$tumor.allele_freq) >= MIN_VAF)

# Remove non-panel genes
mutect.snvs <- filter(mutect.snvs, mutect.snvs$gene %in% genes.panel)

# keep only variants that have a protein-altering impact
effects.exclude <- c("intron_variant", "intragenic_variant", "", "sequence_feature")
mutect.snvs <- filter(mutect.snvs, !(mutect.snvs$effect %in% effects.exclude))
mutect.snvs <- filter(mutect.snvs, mutect.snvs$impact != "LOW") # filter out low impact variants
mutect.snvs <- filter(mutect.snvs, mutect.snvs$biotype %in% biotype.keeps) # filter out non protein coding biotypes
mutect.snvs <- unique(mutect.snvs[grep("^ENST", mutect.snvs$feature_id), ])# annotated on Ensembl transcript ID


# Filters with sample-specific criteria
# ---------------------------------------

# apply different filters depending on the type of normal (LMD vs. not LMD)
mutect.snvs <- filter(mutect.snvs, 
                           ( (normal.extraction_method %in% normals.LMD) &
                             (as.numeric(normal.allele_freq) < MAX_VAR_AF_NORMAL.LMD_OPT)
                           ) | 
                           ( (!(normal.extraction_method %in% normals.LMD) | is.na(normal.extraction_method)) &
                             (as.numeric(normal.allele_freq) < 0.05*as.numeric(tumor.allele_freq)) &
                             (as.numeric(normal.var_reads) <= MAX_VAR_READS_NORMAL)
                           ) 
                        )

# Remove variants with a *pooled normal* that only have a dbSNP id
# Psuedocode:
#   1) Store variants from tumors matched to non-pooled normal
#   2) Store variants from tumors matched to pooled normal and do not have an rs id (no ids, or COSM id(s))
#   3) Store variants from tumors matched to pooled normal and do have an rs id (rs + COSM id(s), or rs id)
#   4) Store variants from (3) that have a COSM id
#   5) Remove list of variants from (3)
#   6) Rbind variants from 1, 2 and 4
mutect.not_pooledN <- filter(mutect.snvs, !(normal.extraction_method %in% normals.pooled)) # dataset 1
mutect.pooledN <- filter(mutect.snvs, normal.extraction_method %in% normals.pooled)
mutect.pooledN.no_rsid <- filter(mutect.pooledN, !grepl("rs", mutect.pooledN$external_id)) # dataset 2
mutect.pooledN.rsid <- filter(mutect.pooledN, grepl("rs", mutect.pooledN$external_id)) # dataset 3
mutect.pooledN.rs_and_COSM_id <- filter(mutect.pooledN.rsid, grepl("COSM", mutect.pooledN.rsid$external_id)) # 4
rm(mutect.pooledN.rsid)
rm(mutect.pooledN)
mutect.snvs <- rbind(mutect.not_pooledN, mutect.pooledN.no_rsid, mutect.pooledN.rs_and_COSM_id)

# ROC-based thresholds
mutect.snvs <- filter(mutect.snvs, 
                      (as.numeric(mutect.snvs$tumor_content) > 25 & 
                         as.numeric(mutect.snvs$tumor.var_reads) >= MIN_VAR_READS_TUMOR.HIGH_TC) |
                        (as.numeric(mutect.snvs$tumor_content) <= 25 & 
                           as.numeric(mutect.snvs$tumor.var_reads) >= MIN_VAR_READS_TUMOR.LOW_TC))


# Germline filter for "pooled normal" (and not pooled LMD normal) - remove variants with VAF between 40-60, >90 (except variants with COSM id only)
## pseudocode:
#   1. Split up calls into (1) pooled normal and (2) everything else --> "not pooled normal"
#   2. For calls in (1) above, keep variants that have VAF < 40 or VAF between 60 and 90% --> "pooled, filtered VAF"
#   3. Create temporary set of calls that are inverse of above (i.e. have VAF between 40-60 or >= 90%)
#   4. Keep calls from above dataset that have COSMIC id and not rs id --> "pooled, filtered out with COSMIC id"
#   5. Combine "not pooled normal" + "pooled, filtered VAF" + "pooled, filtered out with COSMIC id"

# Step 1 - 
mutect.snvs.pooledN <- filter(mutect.snvs, mutect.snvs$normal.extraction_method == "pooled normal")
mutect.snvs.not_pooledN <- filter(mutect.snvs, mutect.snvs$normal.extraction_method != "pooled normal") # keep all
# Step 2 - 
mutect.snvs.pooledN.filtered <- filter(mutect.snvs.pooledN, (as.numeric(tumor.allele_freq) < 40) | 
                                           (as.numeric(tumor.allele_freq) > 60 & as.numeric(tumor.allele_freq) < 90) ) # keep
# Step 3 - 
mutect.snvs.pooledN.filtered_out.temp <- filter(mutect.snvs.pooledN, (as.numeric(tumor.allele_freq) >= 90) | 
                                               (as.numeric(tumor.allele_freq) >= 40 & as.numeric(tumor.allele_freq) <= 60) )
# Step 4 - 
mutect.snvs.pooledN.filtered_out.temp.COSM <- filter(mutect.snvs.pooledN.filtered_out.temp, 
                                                       grepl("COSM", mutect.snvs.pooledN.filtered_out.temp$external_id) )
mutect.snvs.pooledN.filtered_out.temp.COSM_not_rs <- filter(mutect.snvs.pooledN.filtered_out.temp.COSM,
                                                              !grepl("rs", mutect.snvs.pooledN.filtered_out.temp.COSM$external_id)) # keep

mutect.snvs <- rbind(mutect.snvs.not_pooledN, mutect.snvs.pooledN.filtered, mutect.snvs.pooledN.filtered_out.temp.COSM_not_rs)

# remove duplicates (e.g. due to multiple effects)
mutect.snvs <- unique(mutect.snvs)	

write.table(mutect.snvs, "/Volumes/shung/projects/gzl_targeted/all_samples/mutect/mutect.snvs.filtered.txt", sep = "\t", quote = FALSE, row.names = FALSE)
	
mutect.snvs$combine = as.character(paste(
  mutect.snvs$tumor.id,
  mutect.snvs$type,
  mutect.snvs$chr,
  mutect.snvs$pos,
  mutect.snvs$ref,
  mutect.snvs$alt,
  sep = "."
))

```

## ####### ##
## STRELKA ##
## ####### ##

Extracting alelle frequencies for strelka SNVs:

refCounts = value in "GEN.TUMOR..XU" column; where REF = X {A, C, G, T}
altCounts = value in "GEN.TUMOR..YU" column; where ALT = Y {A, C, G, T}
tier1RefCounts = first comma-delimited value from refCounts
tier1AltCounts = first comma-delimited value from altCounts
somatic allele frequency = tier1AltCounts / (tier1AltCounts + tier1RefCounts)
  
Extracting allele frequencies for strelka indels:

tier1RefCounts = first comma-delimited value in TAR
tier1AltCounts = first comma-delimited value in TIR
somatic allele frequency = tier1AltCounts / (tier1AltCounts + tier1RefCounts)
  
```{r}
strelka.snvs <- read.table("/Volumes/shung/projects/gzl_targeted/all_samples/strelka/all.snvs.txt", sep = "\t", header = TRUE, fill = TRUE)
strelka.indels <- read.table("/Volumes/shung/projects/gzl_targeted/all_samples/strelka/all.indels.txt", sep = "\t", header = TRUE, fill = TRUE)
```

## Strelka - Processing data for filtering

```{r}
# label type of mutation
strelka.snvs$type <- "snv"
strelka.indels$type <- "indel"

# create a tumor_id column based on the sample id (format is <tumor_id>_<normal_id>) 
strelka.snvs$tumor.id <- gsub("(.*)\\_(.*)","\\1", strelka.snvs$SAMPLE)
strelka.indels$tumor.id <- gsub("(.*)\\_(.*)","\\1", strelka.indels$SAMPLE)
strelka.snvs$normal.id <- gsub("(.*)\\_(.*)","\\2", strelka.snvs$SAMPLE)
strelka.indels$normal.id <- gsub("(.*)\\_(.*)","\\2", strelka.indels$SAMPLE)

# extract columns for filtering: variant tumor reads, allele frequency, effect, gene

# columns of unknown meaning:
#   "GEN.NORMAL..FDP"
#   "GEN.TUMOR..FDP" 

## Extract somatic variant allele frequencies from strelka snvs - 5 steps:
## Note that the steps are the same for calculating tumor and normal (except column names are different)

# 1) refCounts = value in "GEN.TUMOR..XU" column; where REF = X {A, C, G, T}
strelka.snvs <- strelka.snvs %>%
  mutate(refCounts = ifelse(as.character(REF) == "A", as.character(strelka.snvs$GEN.TUMOR..AU),
                            ifelse(as.character(REF) == "C", as.character(strelka.snvs$GEN.TUMOR..CU),
                                   ifelse(as.character(REF) == "G", as.character(strelka.snvs$GEN.TUMOR..GU),
                                          as.character(strelka.snvs$GEN.TUMOR..TU)))))
strelka.snvs <- strelka.snvs %>%
  mutate(normal.refCounts = ifelse(as.character(REF) == "A", as.character(strelka.snvs$GEN.NORMAL..AU),
                            ifelse(as.character(REF) == "C", as.character(strelka.snvs$GEN.NORMAL..CU),
                                   ifelse(as.character(REF) == "G", as.character(strelka.snvs$GEN.NORMAL..GU),
                                          as.character(strelka.snvs$GEN.NORMAL..TU)))))

# 2) altCounts = value in "GEN.TUMOR..YU" column; where ALT = Y {A, C, G, T}
strelka.snvs <- strelka.snvs %>%
  mutate(altCounts = ifelse(as.character(ALT) == "A", as.character(strelka.snvs$GEN.TUMOR..AU),
                            ifelse(as.character(ALT) == "C", as.character(strelka.snvs$GEN.TUMOR..CU),
                                   ifelse(as.character(ALT) == "G", as.character(strelka.snvs$GEN.TUMOR..GU),
                                          as.character(strelka.snvs$GEN.TUMOR..TU)))))
strelka.snvs <- strelka.snvs %>%
  mutate(normal.altCounts = ifelse(as.character(ALT) == "A", as.character(strelka.snvs$GEN.NORMAL..AU),
                            ifelse(as.character(ALT) == "C", as.character(strelka.snvs$GEN.NORMAL..CU),
                                   ifelse(as.character(ALT) == "G", as.character(strelka.snvs$GEN.NORMAL..GU),
                                          as.character(strelka.snvs$GEN.NORMAL..TU)))))

# 3) tier1RefCounts = first comma-delimited value from refCounts
strelka.snvs <-	
  separate(data = strelka.snvs,	
           col = refCounts,	
           into = c("tier1RefCounts", "tier2RefCounts"),	
           sep = ",",	convert = TRUE,
           remove = FALSE)
strelka.snvs$tier2RefCounts <- NULL

strelka.snvs <-	
  separate(data = strelka.snvs,	
           col = normal.refCounts,	
           into = c("normal.tier1RefCounts", "normal.tier2RefCounts"),	
           sep = ",",	convert = TRUE,
           remove = FALSE)
strelka.snvs$normal.tier2RefCounts <- NULL

# 4) tier1AltCounts = first comma-delimited value from altCounts
strelka.snvs <-	
  separate(data = strelka.snvs,	
           col = altCounts,	
           into = c("tier1AltCounts", "tier2AltCounts"),	
           sep = ",",	convert = TRUE,
           remove = FALSE)
strelka.snvs$tier2AltCounts <- NULL

strelka.snvs <-	
  separate(data = strelka.snvs,	
           col = normal.altCounts,	
           into = c("normal.tier1AltCounts", "normal.tier2AltCounts"),	
           sep = ",",	convert = TRUE,
           remove = FALSE)
strelka.snvs$normal.tier2AltCounts <- NULL

# 5) somatic allele frequency = tier1AltCounts / (tier1AltCounts + tier1RefCounts)
strelka.snvs$tumor.allele_freq <- 
  ( strelka.snvs$tier1AltCounts / (strelka.snvs$tier1AltCounts + strelka.snvs$tier1RefCounts) ) * 100
strelka.snvs$normal.allele_freq <- (strelka.snvs$normal.tier1AltCounts / (strelka.snvs$normal.tier1AltCounts + strelka.snvs$normal.tier1RefCounts) ) * 100

# create intuitive columns to represent (tumor/normal) depth and (tumor/normal) variant depth:
strelka.snvs$tumor.depth <- strelka.snvs$tier1AltCounts + strelka.snvs$tier1RefCounts
strelka.snvs$tumor.var_depth <- strelka.snvs$tier1AltCounts
strelka.snvs$normal.depth <- strelka.snvs$normal.tier1AltCounts + strelka.snvs$normal.tier1RefCounts
strelka.snvs$normal.var_depth <- strelka.snvs$normal.tier1AltCounts


## Extract somatic variant allele frequencies from strelka indels - 3 steps:

# 1) tier1RefCounts = first comma-delimited value in TAR
strelka.indels <-
  separate(data = strelka.indels,
           col = GEN.TUMOR..TAR,
           into = c("tier1RefCounts", "tier2RefCounts"),
           sep = ",", convert = TRUE,
           remove = FALSE)
strelka.indels$tier2RefCounts <- NULL

strelka.indels <-
  separate(data = strelka.indels,
           col = GEN.NORMAL..TAR,
           into = c("normal.tier1RefCounts", "normal.tier2RefCounts"),
           sep = ",", convert = TRUE,
           remove = FALSE)
strelka.indels$normal.tier2RefCounts <- NULL

# 2) tier1AltCounts = first comma-delimited value in TIR
strelka.indels <-
  separate(data = strelka.indels,
           col = GEN.TUMOR..TIR,
           into = c("tier1AltCounts", "tier2AltCounts"),
           sep = ",", convert = TRUE,
           remove = FALSE)
strelka.indels$tier2AltCounts <- NULL

strelka.indels <-
  separate(data = strelka.indels,
           col = GEN.NORMAL..TIR,
           into = c("normal.tier1AltCounts", "normal.tier2AltCounts"),
           sep = ",", convert = TRUE,
           remove = FALSE)
strelka.indels$normal.tier2AltCounts <- NULL

# 3) somatic allele frequency = tier1AltCounts / (tier1AltCounts + tier1RefCounts)
strelka.indels$tumor.allele_freq <- 
  (strelka.indels$tier1AltCounts / (strelka.indels$tier1AltCounts + strelka.indels$tier1RefCounts) )*100

strelka.indels$normal.allele_freq <- 
  (strelka.indels$normal.tier1AltCounts / (strelka.indels$normal.tier1AltCounts + strelka.indels$normal.tier1RefCounts) )*100

# create intuitive columns to represent (tumor/normal) depth and (tumor/normal) variant depth:
strelka.indels$tumor.depth <- strelka.indels$tier1AltCounts + strelka.indels$tier1RefCounts
strelka.indels$tumor.var_depth <- strelka.indels$tier1AltCounts
strelka.indels$normal.depth <- strelka.indels$normal.tier1AltCounts + strelka.indels$normal.tier1RefCounts
strelka.indels$normal.var_depth <- strelka.indels$normal.tier1AltCounts

# extract only columns of interest so that we can combine snvs and indels
keeps <- c("tumor.id", "normal.id", "type", "CHROM", "POS", "ANN....GENE", "REF", "ALT",
                 "ANN....HGVS_C", "ANN....HGVS_P", "normal.depth", "normal.var_depth", "normal.allele_freq",
                 "tumor.depth", "tumor.var_depth", "tumor.allele_freq", "ANN....EFFECT", "ANN....IMPACT",
                 "ANN....BIOTYPE", "ID", "ANN....FEATUREID", "LOF....GENE", "LOF....GENEID", "LOF....NUMTR", "LOF....PERC")
strelka.indels <- strelka.indels[, keeps]
strelka.snvs <- strelka.snvs[, keeps]

# combine snvs and indels into a single calls dataframe
strelka.calls <- rbind(strelka.snvs, strelka.indels)
rm(strelka.indels)	
rm(strelka.snvs)

# rename columns so they are more intuitive:
colnames(strelka.calls) <- c("tumor.id", "normal.id", "type", "chr", "pos", "gene", "ref", "alt",
                             "hgvs_cdna", "hgvs_protein", "normal.depth", "normal.var_reads", "normal.allele_freq",
                             "tumor.depth", "tumor.var_reads", "tumor.allele_freq", "effect", "impact", "biotype",
                             "external_id", "feature_id", "LOF_gene", "LOF_geneid", "LOF_num_Tr", "LOF_perc")

# rename specific tumor ids so that sample information can be properly mapped
tumor_id.to.mappable_tumor_id <- c("GZ-170-merged.sorted"="GZ-170-merged")
strelka.calls$tumor.id <- revalue(strelka.calls$tumor.id, tumor_id.to.mappable_tumor_id)

# remove excluded samples
strelka.calls <- filter(strelka.calls, strelka.calls$tumor.id %in% sample.data$tumor.id)

# merge T-N data with SNVs to apply additional filters
strelka.calls <- merge(strelka.calls, sample.data, by = "tumor.id", all.x = TRUE)

# map three-letter amino acid codes to one-letter codes
strelka.calls <- FindReplace(data = strelka.calls, 	
                                    Var = "hgvs_protein",	
                                    replaceData = AA.replaces,	
                                    from = "from",	
                                    to = "to",	
                                    exact = FALSE)	

```

## Strelka - Filtering

```{r}
# note strand bias filter cannot be applied to mutect calls since no strand-specific information is output

# Strelka-specific filters - min tumor depth
# --------------------------------------------------------

# unlike in VarScan, depth at variant position is not filtered; filter for min 20X coverage
strelka.calls <- filter(strelka.calls, as.numeric(tumor.depth) >= MIN_DEPTH)

# Filters that are applied to all samples
# ---------------------------------------

strelka.calls <- filter(strelka.calls, as.numeric(strelka.calls$tumor.allele_freq) >= MIN_VAF)

# Remove non-panel genes
strelka.calls <- filter(strelka.calls, strelka.calls$gene %in% genes.panel)

# keep only variants that have a protein-altering impact
effects.exclude <- c("intron_variant", "intragenic_variant", "", "sequence_feature")
strelka.calls <- filter(strelka.calls, !(strelka.calls$effect %in% effects.exclude))
strelka.calls <- filter(strelka.calls, strelka.calls$impact != "LOW") # filter out low impact variants
strelka.calls <- filter(strelka.calls, strelka.calls$biotype %in% biotype.keeps) # filter out non protein coding biotypes
strelka.calls <- unique(strelka.calls[grep("^ENST", strelka.calls$feature_id), ])# annotated on Ensembl transcript ID


# Filters with sample-specific criteria
# ---------------------------------------

# apply different filters depending on the type of normal (LMD vs. not LMD)
strelka.calls <- filter(strelka.calls, 
                           ( (normal.extraction_method %in% normals.LMD) &
                             (as.numeric(normal.allele_freq) < MAX_VAR_AF_NORMAL.LMD_OPT)
                           ) | 
                           ( (!(normal.extraction_method %in% normals.LMD) | is.na(normal.extraction_method)) &
                             (as.numeric(normal.allele_freq) < 0.05*as.numeric(tumor.allele_freq)) &
                             (as.numeric(normal.var_reads) <= MAX_VAR_READS_NORMAL)
                           ) 
                        )

# Remove variants with a *pooled normal* that only have a dbSNP id
# Psuedocode:
#   1) Store variants from tumors matched to non-pooled normal
#   2) Store variants from tumors matched to pooled normal and do not have an rs id (no ids, or COSM id(s))
#   3) Store variants from tumors matched to pooled normal and do have an rs id (rs + COSM id(s), or rs id)
#   4) Store variants from (3) that have a COSM id
#   5) Remove list of variants from (3)
#   6) Rbind variants from 1, 2 and 4
strelka.not_pooledN <- filter(strelka.calls, !(normal.extraction_method %in% normals.pooled)) # dataset 1
strelka.pooledN <- filter(strelka.calls, normal.extraction_method %in% normals.pooled)
strelka.pooledN.no_rsid <- filter(strelka.pooledN, !grepl("rs", strelka.pooledN$external_id)) # dataset 2
strelka.pooledN.rsid <- filter(strelka.pooledN, grepl("rs", strelka.pooledN$external_id)) # dataset 3
strelka.pooledN.rs_and_COSM_id <- filter(strelka.pooledN.rsid, grepl("COSM", strelka.pooledN.rsid$external_id)) # 4
rm(strelka.pooledN.rsid)
rm(strelka.pooledN)
strelka.calls <- rbind(strelka.not_pooledN, strelka.pooledN.no_rsid, strelka.pooledN.rs_and_COSM_id)

# ROC-based thresholds
strelka.calls <- filter(strelka.calls, 
                      (as.numeric(strelka.calls$tumor_content) > 25 & 
                         as.numeric(strelka.calls$tumor.var_reads) >= MIN_VAR_READS_TUMOR.HIGH_TC) |
                        (as.numeric(strelka.calls$tumor_content) <= 25 & 
                           as.numeric(strelka.calls$tumor.var_reads) >= MIN_VAR_READS_TUMOR.LOW_TC))


# Germline filter for "pooled normal" (and not pooled LMD normal) - remove variants with VAF between 40-60, >90 (except variants with COSM id only)
## pseudocode:
#   1. Split up calls into (1) pooled normal and (2) everything else --> "not pooled normal"
#   2. For calls in (1) above, keep variants that have VAF < 40 or VAF between 60 and 90% --> "pooled, filtered VAF"
#   3. Create temporary set of calls that are inverse of above (i.e. have VAF between 40-60 or >= 90%)
#   4. Keep calls from above dataset that have COSMIC id and not rs id --> "pooled, filtered out with COSMIC id"
#   5. Combine "not pooled normal" + "pooled, filtered VAF" + "pooled, filtered out with COSMIC id"

# Step 1 - 
strelka.calls.pooledN <- filter(strelka.calls, strelka.calls$normal.extraction_method == "pooled normal")
strelka.calls.not_pooledN <- filter(strelka.calls, strelka.calls$normal.extraction_method != "pooled normal") # keep all
# Step 2 - 
strelka.calls.pooledN.filtered <- filter(strelka.calls.pooledN, (as.numeric(tumor.allele_freq) < 40) | 
                                           (as.numeric(tumor.allele_freq) > 60 & as.numeric(tumor.allele_freq) < 90) ) # keep
# Step 3 - 
strelka.calls.pooledN.filtered_out.temp <- filter(strelka.calls.pooledN, (as.numeric(tumor.allele_freq) >= 90) | 
                                               (as.numeric(tumor.allele_freq) >= 40 & as.numeric(tumor.allele_freq) <= 60) )
# Step 4 - 
strelka.calls.pooledN.filtered_out.temp.COSM <- filter(strelka.calls.pooledN.filtered_out.temp, 
                                                       grepl("COSM", strelka.calls.pooledN.filtered_out.temp$external_id) )
strelka.calls.pooledN.filtered_out.temp.COSM_not_rs <- filter(strelka.calls.pooledN.filtered_out.temp.COSM,
                                                              !grepl("rs", strelka.calls.pooledN.filtered_out.temp.COSM$external_id)) # keep

strelka.calls <- rbind(strelka.calls.not_pooledN, strelka.calls.pooledN.filtered, strelka.calls.pooledN.filtered_out.temp.COSM_not_rs)

# remove duplicates (e.g. due to multiple effects)
strelka.calls <- unique(strelka.calls)	

write.table(strelka.calls, "/Volumes/shung/projects/gzl_targeted/all_samples/strelka/strelka.calls.filtered.txt", sep = "\t", quote = FALSE, row.names = FALSE)

strelka.calls$combine = as.character(paste(
  strelka.calls$tumor.id,
  strelka.calls$type,
  strelka.calls$chr,
  strelka.calls$pos,
  strelka.calls$ref,
  strelka.calls$alt,
  sep = "."
))
```

## Get all variants

Include variants that are identified in:
  (i) VarScan + MuTect (snvs only)
  (ii) VarScan + Strelka (snvs, indels)
  (iii) MuTect + Strelka (snvs only)
  (iv) all three
  (v) unique to individual tools (*except strelka*, since it has an extraneously high number of variants)

```{r}
# retrieve specific overlaps
calls.varscan_and_mutect_and_strelka <- intersect(intersect(unique(varScan.calls$combine), unique(mutect.snvs$combine)),
                                                  unique(strelka.calls$combine)
                                                  )
calls.varscan_and_mutect_only <- intersect(unique(varScan.calls$combine), unique(mutect.snvs$combine))
calls.varscan_and_strelka_only <- intersect(unique(varScan.calls$combine), unique(strelka.calls$combine))
calls.mutect_and_strelka_only <- intersect(unique(mutect.snvs$ combine), unique(strelka.calls$combine))
#calls.varscan_only
#calls.mutect_only

# now label the "union" table
union.keeps <- c("tumor.id", "normal.id", "type", "chr", "pos", "gene", "ref", "alt", "combine")
varscan.union <- varScan.calls[, union.keeps]
mutect.union <- mutect.snvs[, union.keeps]
#strelka.union <- strelka.calls[, union.keeps]
#calls.union <- unique(rbind(varscan.union, mutect.union, strelka.union))
calls.union <- unique(rbind(varscan.union, mutect.union))

# label by which datasets combine is present in

# check if key is present in the individual datasets
calls.union <- calls.union %>% mutate(datasets = ifelse(combine %in% varScan.calls$combine, "varscan", 
                           ifelse(combine %in% strelka.calls$combine, "strelka", "mutect")))
         
# add more granular labelling
calls.union <- calls.union %>% 
  mutate(datasets = ifelse(combine %in% calls.varscan_and_mutect_only, "varscan, mutect", datasets))
calls.union <- calls.union %>% 
  mutate(datasets = ifelse(combine %in% calls.varscan_and_strelka_only, "varscan, strelka", datasets))
calls.union <- calls.union %>% 
  mutate(datasets = ifelse(combine %in% calls.mutect_and_strelka_only, "mutect, strelka", datasets))
calls.union <- calls.union %>% 
  mutate(datasets = ifelse(combine %in% calls.varscan_and_mutect_and_strelka, "varscan, mutect, strelka", datasets))
calls.union <- unique(calls.union)

to.merge <- c("normal.depth", "normal.var_reads", "normal.allele_freq", 
              "tumor.depth", "tumor.var_reads", "tumor.allele_freq", 
              "hgvs_cdna", "hgvs_protein", "effect", "impact", 
              "biotype", "feature_id", "external_id", "combine")

# add other fields depending on which tool
varscan.calls.to.merge <- varScan.calls[, to.merge]
mutect.calls.to.merge <- mutect.snvs[, to.merge]
#strelka.calls.to.merge <- strelka.calls[, to.merge]

# now arbitrarily split up the calls into varscan-, mutect- and strelka- (in that order) annotatable:
# we do not want to include any variants that are predicted by only 1 tool
varscan.datasets <- c("varscan, strelka", 
                      "varscan, mutect",
                      "varscan, mutect, strelka")
mutect.datasets <- c("mutect, strelka")
#strelka.datasets <- c("varscan, mutect, strelka")

calls.union.varscan.temp <- filter(calls.union, calls.union$datasets %in% varscan.datasets)
calls.union.mutect.temp <- filter(calls.union, calls.union$datasets %in% mutect.datasets)
#calls.union.strelka.temp <- filter(calls.union, calls.union$datasets %in% strelka.datasets)

# now add annotation to individual datasets and combine again
calls.all.varscan <- merge(calls.union.varscan.temp, varscan.calls.to.merge, by = "combine")
calls.all.mutect <- merge(calls.union.mutect.temp, mutect.calls.to.merge, by = "combine")
#calls.all.strelka <- merge(calls.union.strelka.temp, strelka.calls.to.merge, by = "combine")

calls.all <- rbind(calls.all.varscan, calls.all.mutect)
#calls.all <- rbind(calls.all.varscan, calls.all.mutect, calls.all.strelka)
calls.all$combine <- NULL

# merge meta data with variant calls
calls.all <- merge(calls.all, sample.data, by = "tumor.id", all.x = TRUE)

# sort the calls by case, chr, then position	
calls.all <- unique(arrange(calls.all, tumor.id, chr, pos))

# filters to reduce duplicate variants (HGVS_protein and removal of sequence feature effects)
calls.all <- unique(calls.all)

# write out the calls for downstream interpretation
#write.table(calls.all, "/Volumes/shung/projects/gzl_targeted/calls.all/calls.all.unique-union-varscan_mutect_strelka.txt", sep = "\t", row.names = FALSE, quote = FALSE)

# filter out UTR variants for "final" calls
effects.exclude <- c("5_prime_UTR_variant", "3_prime_UTR_variant")
calls.all <- filter(calls.all, !(calls.all$effect %in% effects.exclude))

write.table(calls.all, "/Volumes/shung/projects/gzl_targeted/calls.all/calls.all.unique-union-varscan_mutect_strelka.no_UTRs.txt", sep = "\t", row.names = FALSE, quote = FALSE)

```

## ####################################################
## Integrate final set of target calls with exome calls
## ####################################################

Steps required to integrate the calls:

1. Map target SnpEff mappings to exome mappings (will cause some variants with "conservative_inframe_deletion", "conservative_inframe_insertion", or "non_coding_transcript_variant")

2. Extract common columns between target and exome mutation datasets

3. Add column for type of dataset --> e.g. exome, target, target validation

## Step 1: Map target SnpEff mappings to exome mappings

```{r}
# read in mappings
snpeff.mappings <- read.table("/Volumes/shung/projects/gzl_targeted/data/effect.seq_ontology_to_effect.classic.txt", sep = "\t", header = TRUE)

# remove excluded effects from target dataset
mappings.remove <- filter(snpeff.mappings, snpeff.mappings$effect.classic == "remove")
calls.target.to_integrate <- filter(calls.all, !(calls.all$effect %in% mappings.remove$effect.sequence_ontology))

# map target SnpEff to exome SnpEff
target.snpEff_to_exome.snpEff <- c("disruptive_inframe_deletion"="CODON_CHANGE_PLUS CODON_DELETION",
                                   "disruptive_inframe_insertion"="CODON_CHANGE_PLUS CODON_INSERTION",
                                   "frameshift_variant"="FRAME_SHIFT",
                                   "missense_variant"="NON_SYNONYMOUS_CODING",
                                   "protein_protein_contact"="PROTEIN_PROTEIN_INTERACTION_LOCUS",
                                   "start_lost"="START_LOST",
                                   "stop_gained"="STOP_GAINED",
                                   "stop_lost"="STOP_LOST",
                                   "3_prime_UTR_variant"="UTR_3_PRIME",
                                   "5_prime_UTR_variant"="UTR_5_PRIME",
                                   "frameshift_variant&splice_acceptor_variant&splice_region_variant&intron_variant"="FRAME_SHIFT",
                                   "frameshift_variant&splice_donor_variant&splice_region_variant&intron_variant"="FRAME_SHIFT",
                                   "frameshift_variant&splice_region_variant"="FRAME_SHIFT",
                                   "frameshift_variant&start_lost"="START_LOST",
                                   "frameshift_variant&stop_lost"="FRAME_SHIFT",
                                   "missense_variant&splice_region_variant"="NON_SYNONYMOUS_CODING",
                                   "splice_acceptor_variant&intron_variant"="SPLICE_SITE_ACCEPTOR",
                                   "splice_acceptor_variant&splice_region_variant&5_prime_UTR_variant&intron_variant"="SPLICE_SITE_ACCEPTOR",
                                   "splice_acceptor_variant&splice_region_variant&intron_variant"="SPLICE_SITE_ACCEPTOR",
                                   "splice_donor_variant&conservative_inframe_deletion&splice_region_variant&intron_variant"="SPLICE_SITE_DONOR",
                                   "splice_donor_variant&intron_variant"="SPLICE_SITE_DONOR",
                                   "splice_donor_variant&splice_region_variant&intron_variant"="SPLICE_SITE_DONOR",
                                   "stop_gained&splice_region_variant"="STOP_GAINED")
calls.target.to_integrate$effect <- revalue(calls.target.to_integrate$effect, target.snpEff_to_exome.snpEff)

# write to output file
#write.table(calls.target.to_integrate, "/Volumes/shung/projects/gzl_targeted/calls.all/calls.all-target_with_mapped_snpEff.to_integrate.txt", sep = "\t", quote = FALSE, row.names = FALSE)
```

## Step 2: Extract common columns between target and exome mutation datasets

```{r}
# read in exome calls to be integrated - double check that these do not contain UTR mutations
exome.calls <- read.table("/Volumes/shung/projects/gzl_exomes/snv_analysis-20181127/snv_indel_datasets/snvs_indels.full_cohort_minus_GZ229.default_and_optimized.FINAL_DATASET.txt", sep = "\t", header = TRUE, fill = TRUE)

# remove UTR mutations from exome calls
effects.exclude <- c("UTR_3_PRIME", "UTR_5_PRIME")
exome.calls <- filter(exome.calls, !(exome.calls$effect %in% effects.exclude))

# remove columns that won't be used in the integration
exome.calls$somatic_p_value <- NULL
exome.calls$somatic_status <- NULL
exome.calls$gt_normal <- NULL
exome.calls$gt_tumor <- NULL
exome.calls$thresholds <- NULL
exome.calls$gmaf <- NULL
exome.calls$fun_class <- NULL
exome.calls$HGVS_DNA <- NULL

# split the HGVS column into HGVS protein and HGVS cds
# NB: need to account for cases that migth not have one or both
# e.g. in many cases, there will only be the CDS annotation present - in cases like this, it will get assigned to the first column listed in the "into" parameter of separate
exome.calls <-
  separate(data = exome.calls,
           col = HGVS_protein,
           into = c("hgvs_protein", "hgvs_cdna"),
           sep = "/",
           remove = TRUE,
           fill = "left")

# mappings for 3-letter amino acids to 1-letter amino acid codes
AA.replaces <- data.frame(from = c("Ala", "Arg", "Asn", "Asp", "Asx", "Cys", "Glu", "Gln", "Glx", "Gly", "His", 
                                   "Ile", "Leu", "Lys", "Met", "Phe", "Pro", "Ser", "Thr", "Trp", "Tyr", "Val"), 
                          to = c("A", "R", "N", "D", "B", "C", "E", "Q", "Z", "G", "H", 
                                 "I", "L", "K", "M", "F", "P", "S", "T", "W", "Y", "V"))

exome.calls <- FindReplace(data = exome.calls, 
                                    Var = "hgvs_protein",
                                    replaceData = AA.replaces,
                                    from = "from",
                                    to = "to",
                                    exact = FALSE)

# rename exome columns to match target columns
colnames(exome.calls) <- c("tumor.id", "normal.id", "type", "chr", "pos", "gene", "ref", "alt",
                           "hgvs_protein", "hgvs_cdna", "normal.allele_freq", "tumor.allele_freq", 
                           "normal.depth4", "tumor.depth4", "normal.var_reads", "tumor.var_reads",
                           "effect", "impact", "transcript_id", "external_id", "callers")

# for exomes: calculate normal depth and tumor depth from depth4 columns (to match target calls)
exome.calls <-	
  separate(data = exome.calls,	
           col = tumor.depth4,	
           into = c("tumor.ref_reads.forward", "tumor.ref_reads.reverse",
                  "tumor.var_reads.forward", "tumor.var_reads.reverse"),	
           sep = ",",	convert = TRUE,
           remove = FALSE)	
exome.calls <-	
  separate(data = exome.calls,	
           col = normal.depth4,	
           into = c("normal.ref_reads.forward", "normal.ref_reads.reverse",
                  "normal.var_reads.forward", "normal.var_reads.reverse"),	
           sep = ",",	convert = TRUE,
           remove = FALSE)	
# calculate tumor depth
exome.calls$tumor.depth <- exome.calls$tumor.ref_reads.forward + exome.calls$tumor.ref_reads.reverse +
  exome.calls$tumor.var_reads.forward + exome.calls$tumor.var_reads.reverse
# calculate normal depth
exome.calls$normal.depth <- exome.calls$normal.ref_reads.forward + exome.calls$normal.ref_reads.reverse +
  exome.calls$normal.var_reads.forward + exome.calls$normal.var_reads.reverse

exome.col_names <- c("tumor.id", "normal.id", "type", "chr", "pos", "gene", "ref", "alt",
                           "hgvs_cdna", "hgvs_protein", "normal.allele_freq", "tumor.allele_freq", 
                           "normal.depth", "tumor.depth", "normal.var_reads", "tumor.var_reads",
                           "effect", "impact", "transcript_id", "external_id", "callers")
exome.calls <- exome.calls[, exome.col_names]

# remove columns that won't be included in the integration
calls.target.to_integrate$tumor.tissue_type <- NULL
calls.target.to_integrate$tumor_content <- NULL
calls.target.to_integrate$tumor.mean_target_coverage <- NULL
calls.target.to_integrate$normal.extraction_method <- NULL
calls.target.to_integrate$biotype <- NULL

# rename target calls
names(calls.target.to_integrate)[names(calls.target.to_integrate) == 'datasets'] <- 'callers'
names(calls.target.to_integrate)[names(calls.target.to_integrate) == 'feature_id'] <- 'transcript_id'

# now keep the same order of columns
calls.target.to_integrate <- calls.target.to_integrate[, colnames(exome.calls)]

samples.validation <- read.table("/Volumes/shung/projects/gzl_targeted/roc_analysis/data/samples.all.txt", header = FALSE)

# label target validation, target extension, and exome cohorts
calls.target_validation <- filter(calls.target.to_integrate, calls.target.to_integrate$tumor.id %in% samples.validation$V1)
calls.target_extension <- filter(calls.target.to_integrate, !(calls.target.to_integrate$tumor.id %in% samples.validation$V1))
calls.target_validation$cohort <- "target validation"
calls.target_extension$cohort <- "target extension"
exome.calls$cohort <- "exome"

# combine target and exome calls
calls.all <- rbind(exome.calls, calls.target_validation, calls.target_extension)

# write calls to output
write.table(calls.all, "/Volumes/shung/projects/gzl_targeted/target+exome/calls.all-exome+target-snvs_indels-no_UTR.txt", sep = "\t", quote = FALSE, row.names = FALSE)

```


```{r}
# final variant calls
exome.calls <- read.table("/Volumes/shung/projects/gzl_exomes/snv_analysis-20181127/snv_indel_datasets/snvs_indels.30_final.default_and_optimized.txt", sep = "\t", header = TRUE, fill = TRUE)
target.calls <- read.table("/Volumes/shung/projects/gzl_targeted/calls.all/calls.all.unique-union-varscan_mutect_strelka-minus_temp_excludes.txt", sep = "\t", header = TRUE, fill = TRUE)

# case id mappings
exome.id_mappings <- read.table("/Volumes/shung/projects/gzl_targeted/comparison_to_WES/exome.id_mappings.txt", sep = "\t", header = TRUE)
target.id_mappings <- read.table("/Volumes/shung/projects/gzl_targeted/comparison_to_WES/target.id_mappings.txt", sep = "\t", header = TRUE)

# gene panel
genes.panel <- read.table("/Volumes/shung/projects/gzl_exomes/data/target_panel_Agilent_genes.txt", header=FALSE)
genes.panel <- as.vector(genes.panel$V1)

# map tumor id to case id so that patients ids are comparable between datasets
exome.calls <- merge(exome.calls, exome.id_mappings, by = "tumor_id")
target.calls <- merge(target.calls, target.id_mappings, by = "tumor.id")

# extract columns of interest
exome.keeps <- c("case_id", "type", "chr", "pos", "gene", "ref", "alt", "evidence", 
                 "var_reads_tumor", "allele_freq_tumor", "external_id")
target.keeps <- c("case_id", "type", "chr", "pos", "gene", "ref", "alt", "datasets", 
                  "tumor.var_reads", "tumor.allele_freq", "external_id")
exome.calls <- exome.calls[, exome.keeps]
target.calls <- target.calls[, target.keeps]

# rename columns to be for generating overlap datatset
colnames(exome.calls) <- c("case_id", "type", "chr", "pos", "gene", "ref", "alt", "exome.evidence", 
                           "exome.tumor.var_reads", "exome.tumor.allele_freq", "exome.external_id")
colnames(target.calls) <- c("case_id", "type", "chr", "pos", "gene", "ref", "alt", "target.evidence", 
                            "target.tumor.var_reads", "target.tumor.allele_freq", "target.external_id")

# filter datasets so they are comparable at the gene level and patient level
exome.calls <- filter(exome.calls, exome.calls$gene %in% genes.panel)
exome.calls <- filter(exome.calls, exome.calls$case_id %in% unique(target.calls$case_id))
target.calls <- unique(filter(target.calls, target.calls$case_id %in% unique(exome.calls$case_id)))

# create a "union" table
union.keeps <- c("case_id", "type", "chr", "pos", "gene", "ref", "alt")
exome.union <- exome.calls[, union.keeps]
target.union <- target.calls[, union.keeps]
all.union <- unique(rbind(exome.union, target.union))

# create a "key" for comparison of mutations
exome.calls$combine = as.character(paste(
  exome.calls$case_id,
  exome.calls$type,
  exome.calls$chr,
  exome.calls$pos,
  exome.calls$ref,
  exome.calls$alt,
  sep = "."
))

target.calls$combine = as.character(paste(
  target.calls$case_id,
  target.calls$type,
  target.calls$chr,
  target.calls$pos,
  target.calls$ref,
  target.calls$alt,
  sep = "."
))

all.union$combine = as.character(paste(
  all.union$case_id,
  all.union$type,
  all.union$chr,
  all.union$pos,
  all.union$ref,
  all.union$alt,
  sep = "."
))

# retrieve specific overlaps
calls.exome_and_target <- intersect(unique(exome.calls$combine), unique(target.calls$combine))

# label by which datasets combine is present in
all.union <- all.union %>% mutate(source = ifelse(combine %in% exome.calls$combine, "exome", "target"))
# add more granular labelling
all.union <- all.union %>%
  mutate(source = ifelse(combine %in% calls.exome_and_target, "exome + target", source))
all.union <- unique(all.union)

# add extra columns that are specific to each dataset
exome.to_merge <- c("combine", "exome.evidence", "exome.tumor.var_reads", "exome.tumor.allele_freq", "exome.external_id")
exome.calls.to_merge <- exome.calls[, exome.to_merge]
target.to_merge <- c("combine", "target.evidence", "target.tumor.var_reads", "target.tumor.allele_freq", "target.external_id")
target.calls.to_merge <- target.calls[, target.to_merge]

# now add annotation
all.union <- merge(all.union, exome.calls.to_merge, by = "combine", all.x = TRUE)
all.union <- merge(all.union, target.calls.to_merge, by = "combine", all.x = TRUE)
all.union$combine <- NULL

# sort the calls by case, chr, then position	
all.union <- unique(arrange(all.union, case_id, chr, pos))

# write out the calls for downstream interpretation
write.table(all.union, "/Volumes/shung/projects/gzl_targeted/comparison_to_WES/calls-WES_vs_targeted.txt", sep = "\t", row.names = FALSE, quote = FALSE)
```

